
# 민석이는 불면증에 걸렸다. 그래서 잠이 안 올 때의 민간요법 중 하나인 양 세기를 하려고 한다.

# 민석이는 1번 양부터 순서대로 세는 것이 재미없을 것 같아서 N의 배수 번호인 양을 세기로 하였다.

# 즉, 첫 번째에는 N번 양을 세고, 두 번째에는 2N번 양, … , k번째에는 kN번 양을 센다.

# 이렇게 숫자를 세던 민석이에게 잠은 더 오지 않고 다음과 같은 궁금증이 생겼다.

# 이전에 셌던 번호들의 각 자리수에서 0에서 9까지의 모든 숫자를 보는 것은 최소 몇 번 양을 센 시점일까?

# 예를 들어 N = 1295이라고 하자.

# 첫 번째로 N = 1295번 양을 센다. 현재 본 숫자는 1, 2, 5, 9이다.

# 두 번째로 2N = 2590번 양을 센다. 현재 본 숫자는 0, 2, 5, 9이다.

# 현재까지 본 숫자는 0, 1, 2, 5, 9이다.

# 세 번째로 3N = 3885번 양을 센다. 현재 본 숫자는 3, 5, 8이다.

# 현재까지 본 숫자는 0, 1, 2, 3, 5, 8, 9이다.

# 네 번째로 4N = 5180번 양을 센다. 현재 본 숫자는 0, 1, 5, 8이다.

# 현재까지 본 숫자는 0, 1, 2, 3, 5, 8, 9이다.

# 다섯 번째로 5N = 6475번 양을 센다. 현재 본 숫자는 4, 5, 6, 7이다.

# 현재까지 본 숫자는 0, 1, 2, 3, 4, 5, 6, 7, 8, 9이다.

# 5N번 양을 세면 0에서 9까지 모든 숫자를 보게 되므로 민석이는 양 세기를 멈춘다.

# [입력]

# 첫 번째 줄에 테스트 케이스의 수 T가 주어진다.

# 각 테스트 케이스의 첫 번째 줄에는 N (1 ≤ N ≤ 106)이 주어진다.
T = int(input())
# 여러개의 테스트 케이스가 주어지므로, 각각을 처리합니다.
for test_case in range(1, T + 1):
    n=input()
    nlist=[]
    count = 1
    # r = n*(count-1)

    while len(nlist) != 10: # 입력되는 숫자의 0~9를 겹치지 않게 리스트에 넣어서 총 숫자가 10개가 된다면 멈춤
        nm = int(n)*count    # n * conut  입력된 숫자에 한번 반복될때마다 +1되는 cnt 를 더 해서 자리수마다 값을 구한후 
                             #리스트에 없을경우 플러스
                            #n의수는 변하지않고 카운트만 변해야한다.
        nm = str(nm)             # len이 int로 정의된 값을 세어주지 않기에 숫자로 형변환 후 카운트를 곱하고 다시 str로 바꾼다.
        for i in range(len(nm)):   # n의 자리수 길이 확인 
            if (nm[i:i+1]) not in nlist : # 자리수 마다 한자리씩 옮기면서 리스트에 없을 경우 리스트에 추가해줌
                nlist.append(nm[i:i+1])
            # print(nlist)
        count = count+ 1
    print(f'#{test_case} {int(n)*(count-1)}')
        # if len(nlist) == 10:
        #     break
