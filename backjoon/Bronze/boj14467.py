# 닭이 길을 건너간 이유는 과학적으로 깊게 연구가 되어 있지만, 의외로 소가 길을 건너간 이유는 거의 연구된 적이 없다. 이 주제에 관심을 가지고 있었던 농부 존은 한 대학으로부터 소가 길을 건너는 이유에 대한 연구 제의를 받게 되었다.

# 존이 할 일은 소가 길을 건너는 것을 관찰하는 것이다. 존은 소의 위치를 N번 관찰하는데, 각 관찰은 소의 번호와 소의 위치 하나씩으로 이루어져 있다. 존은 소를 10마리 가지고 있으므로 소의 번호는 1 이상 10 이하의 정수고, 소의 위치는 길의 왼쪽과 오른쪽을 의미하는 0과 1 중 하나다.

# 이 관찰 기록을 가지고 소가 최소 몇 번 길을 건넜는지 알아보자. 즉 같은 번호의 소가 위치를 바꾼 것이 몇 번인지 세면 된다.


# 5         # 관찰횟수 
# 5 0       # 왼쪽은 소의 번호 오른쪽은 관측 때  소가 위치한 곳  0번길(왼쪽) 1번길(오른쪽)
# 5 1       # 각 행마다 관측된 소가 자리를 옮겼다면 움직인 횟수 +1 
# 4 1       # 마지막에 관측된 소들이 몇번 움직였는지 확인하기
# 4 0
# 3 0  
 


n=int(input())

cow=[0]*(11)    # 소는 최대 10마리 소번호는 0번이 없을 수 도 있으니 0~10까지의 인덱스 리스트를 만듬

load = [3]*(11) # 소가 있는 위치 임의의 수 3 은 목장으로 가정,  소가 관측된다면 위치를 갱신해준다

for __ in range(n):   # 입력받은 n번은 소를 관측한 횟수
    x,y = map(int,input().split()) # 소를 관측
    if load[x]==y: # 입력받은 수로 길의 인덱스 (소의번호)를 찾아 소가 존재하는 위치(처음에는 목장에 있다고 가정)를   같다면 패스              
        pass                                                    #0 (왼쪽길) or 1 (오른쪽길)
    elif load[x]!=y: # 위치가 입력된 값과 다르다면 cow 소 번호 인덱스에 숫자 1을 더해준다.
        load[x]=y
        cow[x]+=1
cnt=0

for id in cow:  
    if id> 1:    # 처음 관측할 때 목장에서 길로 나온다고 가정을 하여 관측된 순간 카운트가 +1 이 되어있으니 2이상인 수만 뽑는다.
        cnt+= (id-1) # 마지막 카운트에 넣을때는 관측될 때 추가된 1의 값을 뺀 후 더해준다.

print(cnt)

