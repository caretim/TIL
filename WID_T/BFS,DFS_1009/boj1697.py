# 수빈이는 동생과 숨바꼭질을 하고 있다. 수빈이는 현재 점 N(0 ≤ N ≤ 100,000)에 있고, 동생은 점 K(0 ≤ K ≤ 100,000)에 있다. 수빈이는 걷거나 순간이동을 할 수 있다. 만약, 수빈이의 위치가 X일 때 걷는다면 1초 후에 X-1 또는 X+1로 이동하게 된다. 순간이동을 하는 경우에는 1초 후에 2*X의 위치로 이동하게 된다.

# 수빈이와 동생의 위치가 주어졌을 때, 수빈이가 동생을 찾을 수 있는 가장 빠른 시간이 몇 초 후인지 구하는 프로그램을 작성하시오.

# 최단 거리 찾기
from collections import deque


n, k = map(int, input().split())
# n에서 k까지 최단거리 찾기 방법은 -1,+1 ,*2 세가지를 통해 최단거리로 가는법


maxnum = 100000  # 문제에 지정된 최대범위 100000


start = n



visit = [0] * (maxnum + 1)  # 방문처리 리스트와 몇 초를 사용했는지 기록을 겸해서 사용

result = 0


def bfs(start):
    q = deque()  # bfs탐색을 위해 후입선출을 위한 deque 사용
    q.append(start)
    while q:  # q의 리스트 안의 값이 빈 공간이되면 정지
        check = q.popleft()  # q리스트의 맨 앞의 값을 pop을 통해 가져옴
        if check == k:  # 가져온 값이 도착해야할 거리 k라면 프린트 후 정지
            result = visit[
                check
            ]  #  리스트에 소요된 시간을 방출한다. 가장 먼저 값이 같게되는 것이 소모되는 시간이 제일 적음으로 답 출력
            break
        for j in (check - 1, check + 1, check * 2):
            if 0 <= j <= 100000 and visit[j] == 0:  # 방문을 하지않았고 0이상 100000이하라면
                visit[j] = visit[check] + 1  # 여기 오기 위해 소모된 누적된 초를 기록 후 덱에 추가해준다.
                q.append(j)  # 초기 4, 6 10 을 방문하기위해 1초를 사용, 
                # 이후 visit리스트를 통해 소요된 시간 표시
                # 도착하는데 다른 값이 도달했다하더라도 그 값은 이미 다른  빠른 루트를 통해
                # 도착했기에 의미가 없음,
    return print(result)


bfs(n)
